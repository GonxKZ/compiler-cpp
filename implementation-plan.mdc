# Plan de ImplementaciÃ³n - Compilador C++20 para Windows x64

## VisiÃ³n General del Proyecto

Este proyecto implementa un compilador C++20 **verdaderamente desde cero** para Windows x64, con Ã©nfasis en la correcciÃ³n binaria y la interoperabilidad con el ecosistema Microsoft. La estrategia se basa en construir primero un **back-end propio** de cÃ³digo mÃ¡quina y formato COFF/PE antes de integrar LLVM, asegurando que cada capa tenga criterios de salida medibles y verificables.

**EspecificaciÃ³n de Referencia**: Borrador final C++20 (N4861) y documentaciÃ³n ABI x64 de Microsoft
**Objetivo Binario**: ABI x64 de Microsoft completo y formato PE/COFF nativo
**Arquitectura**: Front-end personalizado + Back-end hÃ­brido (propio â†’ LLVM)
**Enfoque**: Desarrollo por capas con dependencias deductivas estrictas

## Arquitectura por Capas (Enfoque "From Scratch" Real)

### ğŸ“‹ **Principio Fundamental**
Cada capa establece invariantes binarias que la siguiente puede asumir como correctas. Sin ABI correcto no hay prÃ³logo/epÃ­logo vÃ¡lido, sin prÃ³logo no hay desenrollado, sin desenrollado no hay EH, y asÃ­ sucesivamente.

---

## ğŸ—ï¸ **Capa 0: NÃºcleo de Ensamblado y Convenciones de Llamada**
**Estado**: ğŸ”„ PrÃ³xima - Base binaria esencial
**Objetivo**: Establecer ABI x64 de Microsoft como contrato binario fundamental

### **Alcance de la Capa 0**
**Contrato Binario Base x86_64-pc-windows-msvc**:
- Registros de paso de argumentos (RCX, RDX, R8, R9 para primeros 4)
- Shadow space de 32 bytes para llamadas
- PreservaciÃ³n de no volÃ¡tiles (RBX, RBP, RDI, RSI, RSP, R12-R15)
- Layout de tipos triviales y homogeneidad de agregados para retorno
- Alineaciones especÃ­ficas del ABI

### **TODOs Capa 0**
- ğŸ”„ Implementar "frame builder" que decide spill slots y preservaciÃ³n
- ğŸ”„ Generador de thunks para variaciones de firma y trampolines
- ğŸ”„ Comprobador estÃ¡tico de invariantes de prÃ³logo/epÃ­logo
- ğŸ”„ Generador de pro-/epÃ­logos conforme a convenciÃ³n x64
- ğŸ”„ Comprobador de usos de pila (shadow space, callee-saved)

### **Criterios de Salida (Verificables)**
- âœ… **abi_calling_convention.cxx**: Valida paso de enteros, FP, agregados y retornos en x64
- âœ… **sum.exe**: Ejecutable funcional que calcula sumas con llamadas correctas
- âœ… **fibonacci.exe**: RecursiÃ³n iterativa y funcional con stack frames vÃ¡lidos
- âœ… **memcpy.exe**: Copia de memoria manual con convenciones correctas
- âœ… **llvm-readobj/dumpbin**: Confirman prÃ³logos/epÃ­logos conforme al ABI

**Referencia**: [Microsoft x64 Calling Convention](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention)

---

## ğŸ—ï¸ **Capa 1: Formato COFF y Relocations**
**Estado**: âœ… Completado - Formato objeto nativo funcional
**Objetivo**: EmisiÃ³n nativa de .obj COFF con relocations AMD64

### **Alcance de la Capa 1**
**Estructuras COFF x64**:
- Secciones .text, .rdata, .data, .pdata, .xdata
- Nombres canÃ³nicos de secciones y tabla de sÃ­mbolos
- Relocations: IMAGE_REL_AMD64_ADDR32, ADDR64, REL32, REL32_1.._5
- Tabla de importaciÃ³n mÃ­nima para kernel32.dll

### **TODOs Capa 1**
- ğŸ”„ COFF writer con estructuras exactas y nombres canÃ³nicos
- ğŸ”„ Soporte para relocations AMD64 esenciales
- ğŸ”„ "Object dumper" propio para validar cabeceras
- ğŸ”„ Tabla de importaciÃ³n estÃ¡tica para CRT bÃ¡sico
- ğŸ”„ VerificaciÃ³n offline de estructuras COFF

### **Criterios de Salida (Verificables)**
- âœ… **hello.obj**: Objeto enlazable con link.exe
- âœ… **dumpbin/llvm-readobj**: Reportan estructuras conformes
- âœ… **link.exe**: Produce ejecutable vÃ¡lido sin errores
- âœ… **hello.exe**: Ejecutable funcional con enlazado estÃ¡tico mÃ­nimo

**Referencia**: [PE/COFF Specification](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)

---

## ğŸ—ï¸ **Capa 2: Desenrollado y Excepciones Windows x64**
**Estado**: â³ Pendiente - Stack unwinding esencial
**Objetivo**: .pdata/.xdata vÃ¡lido para stack unwinding seguro

### **Alcance de la Capa 2**
**Modelo EH Windows x64**:
- Rangos de funciones en .pdata con UNWIND_INFO
- UNWIND_CODE exacto derivable de prÃ³logos/epÃ­logos
- Mapeo try/catch/throw a secuencias invoke/landing pad
- Interoperabilidad con __try/__except y CRT EH

### **TODOs Capa 2**
- ğŸ”„ GramÃ¡tica prÃ³logo/epÃ­logo â†’ UNWIND_CODE automÃ¡tico
- ğŸ”„ Emisor de .xdata/.pdata con validaciÃ³n offline
- ğŸ”„ Mapeo try/catch/throw a IR interno con landing pads
- ğŸ”„ Pruebas cruzadas con __try/__except del CRT
- ğŸ”„ VerificaciÃ³n RaiseException/RtlVirtualUnwind

### **Criterios de Salida (Verificables)**
- âœ… **seh_unwind.cxx**: Lanzamientos/capturas cruzando funciones
- âœ… **RaiseException**: Pasa sin corrupciones de stack
- âœ… **RtlVirtualUnwind**: Desenrollado correcto verificado
- âœ… **catch C++**: Interoperable con runtime MSVC

**Referencia**: [Exception Handling x64](https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64)

---

## ğŸ—ï¸ **Capa 3: Mangling MSVC y Layout de Clases**
**Estado**: â³ Pendiente - Interoperabilidad binaria
**Objetivo**: Nombres decorados y vtables compatibles con MSVC

### **Alcance de la Capa 3**
**Mangling MSVC Completo**:
- Funciones libres, miembros, estÃ¡ticos, plantillas, overloads
- Referencias/punteros a miembros, qualifiers, convenciones
- Vtables/RTTI con layout compatible MSVC
- Type_info structures y virtual dispatch

### **TODOs Capa 3**
- ğŸ”„ Decorado completo compatible con undname.exe
- ğŸ”„ Generador de vtables y type_info para MSVC
- ğŸ”„ Verificador que compara con esquema Microsoft
- ğŸ”„ Pruebas de enlace con funciones MSVC
- ğŸ”„ Virtual dispatch interoperable

### **Criterios de Salida (Verificables)**
- âœ… **mangling_crosslink.cpp**: Objetos nuestros + MSVC linkan
- âœ… **undname.exe**: Confirma decorados idÃ©nticos
- âœ… **Virtual dispatch**: Funciona entre mÃ³dulos mixtos
- âœ… **RTTI**: Compatible con dynamic_cast del CRT

**Referencia**: [MSVC Name Decoration](https://docs.microsoft.com/en-us/cpp/build/decorated-names)

---

## ğŸ—ï¸ **Capa 4: Front-end MÃ­nimo**
**Estado**: â³ Pendiente - AnÃ¡lisis lÃ©xico/sintÃ¡ctico
**Objetivo**: Parser completo con preprocesador y semÃ¡ntica bÃ¡sica

### **Alcance de la Capa 4**
**Front-end C++20 BÃ¡sico**:
- Ocho fases de traducciÃ³n con UCN y concatenaciÃ³n
- Expander de macros con control de re-expansiÃ³n
- Parser recursivo descendente con tentative parsing
- Sistema de sÃ­mbolos y lookups por Ã¡mbito
- Conversiones implÃ­citas y categorÃ­as de valor

### **TODOs Capa 4**
- ğŸ”„ Fases de traducciÃ³n completas con UCNs
- ğŸ”„ Expander de macros con prevenciÃ³n de re-expansiÃ³n
- ğŸ”„ Parser con orÃ¡culo semÃ¡ntico para ambigÃ¼edades
- ğŸ”„ Sistema de tipos con cualificaciones y referencias
- ğŸ”„ Two-phase lookup y ADL bÃ¡sico

### **Criterios de Salida (Verificables)**
- âœ… Programas C++ sin templates complejos compilan
- âœ… Includes y macros no triviales funcionan
- âœ… CÃ³digo binario vÃ¡lido generado
- âœ… DiagnÃ³sticos con ubicaciÃ³n precisa

**Referencia**: [C++20 N4861](https://eel.is/c++draft/)

---

## ğŸ—ï¸ **Capa 5: Plantillas y Conceptos**
**Estado**: â³ Pendiente - Metaprogramming
**Objetivo**: Constraint solver con SFINAE y resoluciÃ³n de sobrecarga

### **Alcance de la Capa 5**
**Sistema de Templates Completo**:
- DeducciÃ³n de argumentos con SFINAE
- ResoluciÃ³n de sobrecarga con conversiones implÃ­citas
- OrdenaciÃ³n parcial y especializaciones
- Constraint solver sobre AST de constraints

### **TODOs Capa 5**
- ğŸ”„ Motor de sustituciÃ³n con contexto de instanciaciÃ³n
- ğŸ”„ Constraint solver con normalizaciÃ³n y subsunciÃ³n
- ğŸ”„ Cacheo por AST y firma de instanciaciÃ³n
- ğŸ”„ DiagnÃ³sticos diferenciados SFINAE vs errores duros

### **Criterios de Salida (Verificables)**
- âœ… LibrerÃ­as con std::enable_if equivalentes funcionan
- âœ… Sobrecargas ambiguas resuelven correctamente
- âœ… requires expressions diagnostican apropiadamente

**Referencia**: [C++20 Templates](https://eel.is/c++draft/temp)

---

## ğŸ—ï¸ **Capa 6: Constexpr y EvaluaciÃ³n**
**Estado**: â³ Pendiente - Compile-time execution
**Objetivo**: VM determinista con memoria abstracta

### **Alcance de la Capa 6**
**Evaluador Constexpr Completo**:
- VM con layout trivial y aliasing definido
- Reglas de constant evaluation estrictas
- Cacheo inteligente de resultados
- Traza de evaluaciÃ³n para debugging

### **TODOs Capa 6**
- ğŸ”„ VM constexpr con operaciones permitidas
- ğŸ”„ Memoria abstracta y lÃ­mites de recursiÃ³n
- ğŸ”„ IntegraciÃ³n con solver de plantillas
- ğŸ”„ DiagnÃ³sticos con traza completa

### **Criterios de Salida (Verificables)**
- âœ… Suites comparan valores con compilador de referencia
- âœ… Uso no permitido rechazado correctamente
- âœ… EvaluaciÃ³n determinista y reproducible

**Referencia**: [C++20 Constant Evaluation](https://eel.is/c++draft/expr.const)

---

## ğŸ—ï¸ **Capa 7: MÃ³dulos C++20**
**Estado**: â³ Pendiente - ModularizaciÃ³n
**Objetivo**: BMI propietario con dependencias y cache

### **Alcance de la Capa 7**
**Sistema de MÃ³dulos**:
- Formato BMI compacto con hash de opciones
- Scanner de dependencias y grafo acÃ­clico
- Cache con invalidaciÃ³n por contenido/flags
- Header units e import <header>

### **TODOs Capa 7**
- ğŸ”„ Scanner de dependencias export/import
- ğŸ”„ Serializador/deserializador BMI
- ğŸ”„ Driver con compilaciÃ³n topolÃ³gica
- ğŸ”„ Coherencia preprocesado/mÃ³dulos

### **Criterios de Salida (Verificables)**
- âœ… **modules_math.{ixx,cpp,main.cpp}**: Compila incremental
- âœ… Evita recompilaciones innecesarias
- âœ… Consistencia entre TUs

**Referencia**: [C++20 Modules](https://eel.is/c++draft/module)

---

## ğŸ—ï¸ **Capa 8: Corroutinas C++20**
**Estado**: â³ Pendiente - Asynchronous programming
**Objetivo**: MÃ¡quina de estados propia con frame layout

### **Alcance de la Capa 8**
**Sistema de Corroutinas**:
- Frame explÃ­cito con punteros de continuaciÃ³n
- DestrucciÃ³n segura y layout ABI-compliant
- InteracciÃ³n con EH para unwinding correcto
- Microbenchmarks vs lowering estilo LLVM

### **TODOs Capa 8**
- ğŸ”„ VerificaciÃ³n estÃ¡tica de promesa y awaitables
- ğŸ”„ Layout de frame con continuaciones
- ğŸ”„ InteracciÃ³n con stack unwinding
- ğŸ”„ GeneraciÃ³n de puntos de suspensiÃ³n/reanudaciÃ³n

### **Criterios de Salida (Verificables)**
- âœ… **coro_pingpong.cpp**: Corroutines alternan correctamente
- âœ… Suspenden/reanudan sin leaks de memoria
- âœ… Limpieza apropiada al finalizar

**Referencia**: [C++20 Coroutines](https://eel.is/c++draft/coroutine)

---

## ğŸ”§ **Infraestructura Transversal**

### **Enlazado HÃ­brido (Fases 1â†’2)**
- **Fase 1**: link.exe como orÃ¡culo para validar .obj COFF
- **Fase 2**: Mini-linker COFFâ†’PE propio
- **Criterio**: Ejecutables que pasan smoke tests

### **Driver CLI Profesional**
- CLI compatible: -c, -E, -S, --emit-bmi, -I, -L, -l
- DetecciÃ³n automÃ¡tica de entorno Windows SDK/CRT
- Sandbox por unidad de compilaciÃ³n

### **Interoperabilidad CRT/SDK**
- __declspec(dllimport/dllexport) y .drectve
- Pruebas con printf, new/delete, std::exception
- Compatibilidad binaria reproducible

### **DiagnÃ³sticos y Performance**
- Mapa de ubicaciones con correspondencia preprocesadoâ†’fuente
- -ftime-report propio con mediciones detalladas
- Caches deterministas para plantillas/constexpr

## ğŸ“Š **MÃ©tricas de Ã‰xito por Capa**

### **Capa 0 (ABI)**: âœ… Ejecutables bÃ¡sicos funcionales
### **Capa 1 (COFF)**: âœ… **COMPLETADO** - .obj enlazables con link.exe
### **Capa 2 (EH)**: â³ Stack unwinding interoperable
### **Capa 3 (Mangling)**: â³ Enlace transparente con MSVC
### **Capa 4 (Front-end)**: â³ C++ bÃ¡sico compila correctamente
### **Capa 5 (Templates)**: â³ Metaprogramming interoperable
### **Capa 6 (Constexpr)**: â³ EvaluaciÃ³n determinista
### **Capa 7 (Modules)**: â³ CompilaciÃ³n incremental
### **Capa 8 (Coroutines)**: â³ Async programming funcional

## âš¡ **Timeline Realista**

- **Capas 0-1**: 8-10 semanas (Base binaria)
- **Capas 2-3**: 6-8 semanas (Interoperabilidad)
- **Capa 4**: 4-6 semanas (Front-end)
- **Capas 5-6**: 6-8 semanas (Templates/Constexpr)
- **Capas 7-8**: 4-6 semanas (Modules/Corrutinas)
- **Testing/Polish**: 4-6 semanas
- **Total**: 32-44 semanas de desarrollo full-time

## ğŸ¯ **Ventajas de Este Enfoque**

### **Verificabilidad**
Cada capa tiene criterios de salida objetivos y medibles en Windows x64

### **Interoperabilidad Garantizada**
Compatibilidad binaria con MSVC desde la primera lÃ­nea de cÃ³digo mÃ¡quina

### **Robustez**
Sin dependencia de LLVM para features crÃ­ticas; back-end hÃ­brido (propioâ†’LLVM)

### **Escalabilidad**
Dependencias deductivas claras permiten desarrollo incremental seguro

---

**Este plan garantiza un compilador C++20 verdaderamente desde cero, con correcciÃ³n binaria verificable en cada paso.**

*Ãšltima actualizaciÃ³n: $(date)*
*Estado del proyecto: Capa 0 âœ… Completada, Capa 1 âœ… Completada, Capa 2 â³ PrÃ³xima*
*Enfoque: Desarrollo por capas con criterios de salida medibles*